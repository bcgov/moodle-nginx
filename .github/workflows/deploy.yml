# Deploy On Openshift
# Builds and Deploys merged PR's to persistent pods/services/routes/etc in the OpenShift environment.
name: Deploy on Openshift

env:
  APP: moodle
  USER: ${{ github.actor }}

on:
  workflow_call:
    inputs:
      BASE_IMAGE_TAG:
        required: true
        type: string
      DB_DEPLOYMENT_NAME:
        required: true
        type: string
      APP:
        required: true
        type: string
      BRANCH:
        required: true
        type: string
      APP_HOST_URL:
        required: true
        type: string
      BUILD_NAMESPACE:
        required: true
        type: string
      DEPLOY_NAMESPACE:
        required: true
        type: string
      WEB_DEPLOYMENT_NAME:
        required: true
        type: string
      PHP_DEPLOYMENT_NAME:
        required: true
        type: string
      DOCKER_FROM_IMAGE:
        required: true
        type: string
      CRON_DEPLOYMENT_NAME:
        required: true
        type: string
    secrets:
      AUTH_TOKEN_DEV:
        required: true
      AUTH_TOKEN_TEST:
        required: true
      AUTH_TOKEN_PROD:
        required: true
    outputs:
      # This is the name of the output set by the workflow_dispatch action.
      # The value is the ID of the workflow run that was triggered.
      deploy1:
        description: "Deployment log"
        value: ${{ jobs.example_job.outputs.output1 }}
      deploy2:
        description: "Deployment log"
        value: ${{ jobs.example_job.outputs.output2 }}
  # push:
  #   paths:
  #     - './openshift/*'
  #     - '**.Dockerfile'
  #     - '**.yml'
  #     - '**.conf'
  #     - '**.ini'
  #     - '**.php'
permissions:
  contents: read
  id-token: write

jobs:
  # Deploy to Openshift
  deploy:
    name: Deploy to OpenShift (${{ github.ref_name }})
    runs-on: ubuntu-latest
    if: |
      always()
      && (
        github.ref_name == 'dev' || github.ref_name  == 'test' || github.ref_name  == 'prod'
      ) || (
        contains(github.event.workflow_run.conclusion, 'success')
        && !contains(github.event.workflow_run.conclusion, 'failure')
      )
    outputs:
      output1: ${{ steps.deploy-to-os.outputs.deploy1 }}
      output2: ${{ steps.deploy-to-os.outputs.deploy2 }}
    steps:
      # Get Environment Variables from file
      - name: Setup Env
        id: dotenv
        uses: falti/dotenv-action@v1
        with:
          path: example.env
          export-variables: true
          log-variables: true
          keys-case: upper

      - name: Checkout Target Branch
        uses: actions/checkout@v2

      # Log in to OpenShift.
      # Note: The secrets needed to log in are NOT available if the PR comes from a FORK.
      # PR's must originate from a branch off the original repo or else all openshift `oc` commands will fail.
      # First, build appropriate secret name for the environement: AUTH_TOKEN_DEV, AUTH_TOKEN_TEST, etc.
      - id: auth_token_string
        uses: ASzc/change-string-case-action@v5
        with:
          string: ${{ format('AUTH_TOKEN_{0}', github.ref_name) }}
      - run: |
          echo "ENV AUTH SECRET NAME: ${{ steps.auth_token_string.outputs.uppercase }}"

      - name: Log in to OpenShift ( DEV )
        if: github.ref_name == 'dev'
        run: |
          oc login --token=${{ secrets.AUTH_TOKEN_DEV }} --server=https://api.silver.devops.gov.bc.ca:6443

      - name: Log in to OpenShift ( TEST )
        if: github.ref_name == 'test'
        run: |
          oc login --token=${{ secrets.AUTH_TOKEN_TEST }} --server=https://api.silver.devops.gov.bc.ca:6443

      - name: Log in to OpenShift ( PROD )
        if: github.ref_name == 'prod'
        run: |
          oc login --token=${{ secrets.AUTH_TOKEN_PROD }} --server=https://api.silver.devops.gov.bc.ca:6443

      - name: Uninstall Redis
        run: helm uninstall redis -n ${{ inputs.DEPLOY_NAMESPACE }} --wait

      - name: Deploy Redis | ${{ steps.dotenv.outputs.REDIS_DEPLOYMENT_NAME }} | ${{ steps.dotenv.outputs.redis_image }}
        if: success() || failure()
        run: |
          helm repo add bitnami https://charts.bitnami.com/bitnami
          helm repo update
          helm install "${{ steps.dotenv.outputs.REDIS_DEPLOYMENT_NAME }} ${{ steps.dotenv.outputs.redis_image }} -f ./config/redis/values.yml"

      - name: Check for DB (MariaDB Galera) Statefulset (${{ inputs.DB_DEPLOYMENT_NAME }})
        id: check-db
        run: |
          if [[ $(oc describe sts ${{ inputs.DB_DEPLOYMENT_NAME  }}) == *"NotFound"* ]]; then
            echo "installed='false'" >> $GITHUB_OUTPUT
          else
            echo "installed='true'" >> $GITHUB_OUTPUT
          fi

      # - name: Deploy DB (MariaDB Galera) [is it installed already? ${{ steps.check-db.outputs.installed }}]
      #   if: steps.check-db.outputs.installed == 'false'
      #   run: |
      #     oc create -f ./config/mariadb/config.yaml -n ${{ inputs.DEPLOY_NAMESPACE }}

      - name: 'Deploy DB (MariaDB Galera) via Helm bot'
        uses: 'deliverybot/helm@v1'
        with:
          release: '${{ inputs.DB_DEPLOYMENT_NAME }}'
          namespace: '${{ github.ref_name }}'
          chart: 'mariadb-galera'
          token: '${{ github.token }}'
          values: |
            name: ${{ inputs.DB_DEPLOYMENT_NAME }}
          value-files: >-
            [
              "./config/mariadb/config.yaml"
            ]

      - name: Deploy OpenShift Template ( ${{ inputs.DEPLOY_NAMESPACE }} ) web, php, cron, with routes, secrets, configmaps
        id: deploy-to-os
        if: success() || failure()
        run: sh ./openshift/scripts/deploy-template.sh
        env:
          APP: ${{ inputs.APP }}
          BRANCH: ${{ inputs.BRANCH }}
          APP_HOST_URL: ${{ inputs.APP_HOST_URL }}
          BUILD_NAMESPACE: ${{ inputs.BUILD_NAMESPACE }}
          DEPLOY_NAMESPACE: ${{ inputs.DEPLOY_NAMESPACE }}
          BASE_IMAGE_TAG: ${{ inputs.BASE_IMAGE_TAG }}
          WEB_DEPLOYMENT_NAME: ${{ steps.dotenv.outputs.web_deployment_name }}
          PHP_DEPLOYMENT_NAME: ${{ steps.dotenv.outputs.php_deployment_name }}
          DOCKER_FROM_IMAGE: ${{ steps.dotenv.outputs.PHP_IMAGE }}
          CRON_DEPLOYMENT_NAME: ${{ steps.dotenv.outputs.cron_deployment_name }}
